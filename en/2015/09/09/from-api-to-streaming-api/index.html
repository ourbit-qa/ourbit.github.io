<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Understanding the differences between an API and a Streaming API and using streamdata.io for converting one into another without writing a single line of code">

    <title>From API to Streaming API - OurBit</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-55d608d53393428d" async="async"></script>
    <!-- Post Header -->
    <!--Google Analytics-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-66576431-1', 'auto');
      ga('send', 'pageview');

    </script>

    <link rel="canonical" href="http://ourbit.github.io//en/2015/09/09/from-api-to-streaming-api/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/en">OurBit</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/en">Home</a>
                </li>
                <li>
                    <a href="/en/about">About</a>
                </li>
                <li>
                    <a href="/en/archives">Archives</a>
                </li>
                <li>
                
                    
                    <a href="/es/2015/09/09/from-api-to-streaming-api/" >Versión en Español</a>
                
              </li>

                <!-- 
                <li>
                    <a href="/es/en/about/">About</a>
                </li>
                
                <li>
                    <a href="/es/about/">Acerca de</a>
                </li>
                
                <li>
                    <a href="/es/archives/">Archivo</a>
                </li>
                
                <li>
                    <a href="/en/archives/">Archives</a>
                </li>
                
                <li>
                    <a href="/en/about/">About</a>
                </li>
                
                <li>
                    <a href="/en/es/about/">Acerca de</a>
                </li>
                
                <li>
                    <a href="/en/es/archives/">Archivo</a>
                </li>
                
                <li>
                    <a href="/es/en/archives/">Archives</a>
                </li>
                
                <li>
                    <a href="/en/feed.xml"></a>
                </li>
                
                <li>
                    <a href="/en/"></a>
                </li>
                 -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <script>
$(window).scroll(function(e) {


     if($(window).scrollTop() <= $(document).height()/2) {
        oVal = ($(window).scrollTop() / 170);
    } else {
        oVal = ($(document).height() -
        $(window).scrollTop() -
        $(window).height()) / 170;

    }



    $(".blur").css("opacity", oVal);
    

});
</script>

<div class="img-src" style="background-image: url('/img/header-background.jpg')"></div>
<div class="img-src blur" style="background-image: url('/img/header-background-blur.jpg')"></div>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>From API to Streaming API</h1>
                    
                    <span class="meta">Posted by nohorbee on
                      
                      
  September 9, 2015


                    </span>
                </div>
            </div>
        </div>
    </div>
</header>
<!-- Post Content -->
<article>
    <div class="content-wrapper">
      <div class="container">
          <div class="row">
              <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

  				<p>There are so many pros on building an <em>API</em> that exposes our application resources. It’s particularly important to achieve reducing tiers coupling to the minimum, but even better, <strong>this allows different applications to access our resources</strong>. For well designed <em>APIs</em> this will also happen in an intuitive way.<br />
But even the best <em>APIs</em> could be implemented in a way that the client needs to make a call every time it needs to know the state of a resource. For this case, the <em>API</em> will have to return the entire resource every time it’s requested.<br />
But, wouldn’t it be more efficient if the <em>API</em> only returned what has changed since the last time it was queried? And wouldn’t it be even more efficient if the client didn’t need to call the <em>API</em> to check if something changed?<br />
<strong><em>Streaming APIs</em></strong> (when implemented properly) try to solve exactly that. On this post we will see how these could be implemented and how <a href="http://streamdata.io">streamdata.io</a> works in order to turn a traditional <em>API</em> into a <em>Streaming API</em>.
<!--MORE--></p>

<h2 id="streaming-apis">Streaming APIs</h2>

<p><strong>A <em>Streaming API</em> is capable of sending notifications to the client.</strong><br />
In traditional <em>HTTP</em> (base protocol for <em>webAPIs</em>) schemas, the client sends a <em>request</em> to the server. The server receives it, understands, even call the proper <em>listeners</em> (if any) and ends returning a <em>response</em> to the client. On this schema, once the server sent the <em>response</em>, it can’t send anything else to the client until this one makes a new <em>request</em>.</p>

<p><img src="/img/posts/traditional-request.png" alt="Traditional HTTP Request" /></p>

<p>But it’s possible for our server to receive the <em>request</em>, process it and even send a <em>response</em>, but leave it <em>on-hold</em> instead of closing it. This way the server could keep sending information to the client for a long period of time. This technique is better known as <strong><em>long polling</em></strong>.</p>

<p><img src="/img/posts/long-polling-request.png" alt="Long Polling HTTP Request" /></p>

<p>By <em>long polling</em>, our <em>API</em> could receive a call and provide the resource that is being requested as a first <em>response</em>. But instead of closing the connection, the <em>API</em> could send new <em>responses</em> in case the resource changes after the first <em>response</em>.<br />
Furthermore, the <em>API</em> could send just the changes that impacted the resource.</p>

<p>Let’s consider the following example</p>

<p><img src="/img/posts/streaming-API-example.png" alt="Streaming API example" /></p>

<p>1- Client 1 sends a <em>request</em> with method <em>GET</em> in order to request a book with id 123321.<br />
2- The server returns a <em>response</em> to the client 1 with a <em>200 OK</em> code and a <em>JSON</em> containing the book information</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="s2">&quot;id&quot;</span><span class="o">:</span> <span class="mi">123321</span><span class="p">,</span>
  <span class="s2">&quot;title&quot;</span><span class="o">:</span> <span class="s2">&quot;My book&quot;</span><span class="p">,</span>
  <span class="s2">&quot;ISBN&quot;</span><span class="o">:</span> <span class="mi">123321</span><span class="p">,</span>
  <span class="s2">&quot;Edition&quot;</span><span class="o">:</span> <span class="s2">&quot;4th&quot;</span>
  <span class="s2">&quot;Year&quot;</span><span class="o">:</span> <span class="mi">2015</span><span class="p">,</span>
  <span class="p">...</span> <span class="c1">// Let&#39;s assume a complex structure with a lot of fields</span>
<span class="p">}</span></code></pre></div>

<p>3- Client 2 sends a <em>request</em> with method <em>PATCH</em> in order to modify the book edition (now “5th”).<br />
4- The server sends a <em>response</em> to the client 2 with a <em>200 OK</em> code.<br />
5- The server sends a  <em>response</em> to the client 1 with a <em>200 OK</em> code and a <em>JSON</em> with the book information.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="s2">&quot;id&quot;</span><span class="o">:</span> <span class="mi">123321</span><span class="p">,</span>
  <span class="s2">&quot;title&quot;</span><span class="o">:</span> <span class="s2">&quot;My book&quot;</span><span class="p">,</span>
  <span class="s2">&quot;ISBN&quot;</span><span class="o">:</span> <span class="mi">123321</span><span class="p">,</span>
  <span class="s2">&quot;Edition&quot;</span><span class="o">:</span> <span class="s2">&quot;5th&quot;</span>
  <span class="s2">&quot;Year&quot;</span><span class="o">:</span> <span class="mi">2015</span><span class="p">,</span>
  <span class="p">...</span> <span class="c1">// Let&#39;s assume a complex structure with a lot of fields</span>
<span class="p">}</span></code></pre></div>

<p><strong>Note:</strong> We are not going into any discussion about which methods should be used (<em>PATCH</em> o <em>PUT</em>) or which <em>HTTP</em> codes. This topics deserve their own post.</p>

<p>Because the server implements <em>long polling</em>, the <em>API</em> is able to notify the client that the previously requested resource has changed, without having the client sending a second <em>request</em>.<br />
The process where <em>APIs proactively</em> notify the client about changes on the resources is known as <em>Push Notification</em>. It worth clarifying that <em>long polling</em> is not the only way of achieving this behaviour. <a href="https://www.websocket.org/"><em>WebSockets</em></a> is another specification that does the trick.</p>

<p>Although the example shows the benefits of implementing <em>Push Notifications</em> as a feature of our <em>Streaming API</em>, the impact regarding to the performance is not neatly visible. Even though is true that the client won’t be periodically sending <em>requests</em> in order to check if the resource changed, each time the <em>API</em> makes a <em>push</em> it will be sending the complete resource to the client. By implementing a <em>differential</em> logic (server side), our <em>API</em> would be able to just notify the updates when sending a <em>push</em>. Considering our previous example, this could go like this:</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="s2">&quot;op&quot;</span><span class="o">:</span> <span class="s2">&quot;PATCH&quot;</span><span class="p">,</span>
  <span class="s2">&quot;/Edition&quot;</span><span class="o">:</span> <span class="s2">&quot;5th&quot;</span>
<span class="p">}</span></code></pre></div>

<p>This <em>JSON</em> informs the client that the field “Edition” has changed. It also informs its new value. The client is now able to update its model according to this information. This way regardless how big a resource is, the <em>push</em> is only sending the fields that have changed since the last update.</p>

<h3 id="request-timeout">Request timeout</h3>

<p>Avoiding infinite time <em>requests</em> is a good practice. Connections could <em>timeout</em> or even could be loss because of servers or network physical conditions. The code impact could be described (in a general way) as</p>

<ul>
  <li>Server: Checks that the <em>response</em> is open before sending data.</li>
  <li>Client: Check that the <em>request</em> is active. Otherwise, make a new <em>request</em>.</li>
</ul>

<p>In case of having too short <em>timeouts</em>, each new <em>request</em> would be receiving the complete resource (again). A known solution consists in sending the server the <em>timestamp</em> of the last received notification. This way, for every <em>request</em> that is not the first one, the server could respond with the updates happened since that <em>timestamp</em>. For a proper implementation, the server side logic should hold a change log of every resource.</p>

<p>This far we have covered an explanation about <em>Streaming APIs</em> and some impelmentation approaches. It’s not this post goal to show a whole concrete example.</p>

<h2 id="from-an-api-to-a-streaming-api">From an API to a Streaming API</h2>

<p>But, what happens when an <em>API</em> is not a <em>Streaming API</em>? The short answer is: We use it as a regular <em>API</em>. It means that, each time we need to know the state of a resource, we will be sending a <em>request</em>.<br />
A more complete answer includes a <em>proxy</em> implementation capable of intercepting a <em>request</em>, storing the <em>response</em>, informing it to the original client, and repeat the operation as many time as needed. This <em>proxy</em> implements <em>long polling</em> which means that it is able to notify the client as soon as a change on a resource is detected. Next diagram shows this scenario.</p>

<p><img src="/img/posts/streaming-API-proxy.png" alt="Streaming API proxy" /></p>

<p>Let’s see what happens on each of the instants (1-4):</p>

<ol>
  <li>Client 1 <em>requests</em> the “book” with id “123321”.<br />
  1.1 The <em>request</em> is not got by the server but by a <em>proxy</em>.<br />
  1.2 The <em>proxy</em> redirects the <em>request</em> to the server.<br />
  1.3 The server returns a <em>response</em> to the <em>proxy</em>.<br />
  1.4 The <em>proxy</em> redirects the <em>response</em> to the client.</li>
  <li>The <em>proxy</em> sends a new <em>request</em> to the server (and it will do that every  X seconds).<br />
  2.1 The server returns a <em>response</em> to the <em>proxy</em>.<br />
  2.2 The <em>proxy</em> compares the fetched resource during this <em>request</em> with the previous one and detects no changes.<br />
  2.3 The <em>proxy</em> doesn’t <em>Push</em> anything to the client.</li>
  <li>Client 2 sends a <em>request</em> with a <em>PATCH</em> method.<br />
  3.1 The client sends the <em>request</em> directly to the server (there is no reason for involving <strong>this kind of</strong> <strong><em>proxy</em></strong> for a “write” operation).<br />
  3.2 The server sends the <em>response</em> confirming the operation.</li>
  <li>The <em>proxy</em> sends a new <em>request</em> to the server (one of those being sent every X segundos).<br />
  4.1 The server sends a  <em>response</em> to the <em>proxy</em>.<br />
  4.2 The <em>proxy</em> compares the fetched resource during this <em>request</em> with the previous one and detects changes.<br />
  4.3 The <em>proxy</em> sends a <em>Push</em> to the client informing the changes (ideally, just the news instead of the complete resource).</li>
</ol>

<p>This way, and without modifying a single line of the <em>API</em> code, we can emulate the behaviour of a <em>streaming API</em> (from the client perspective at least).</p>

<p>What is most interesting about this implementation is that it’s not hard to make it generic for virtually every existing <em>API</em>. It means that we could implement a platform that offers this logic to an <em>API</em> users turning it into a <em>streaming API</em> transparently for both, the <em>API</em> provider and the client.<br />
This is exactly what <a href="http://streamdata.io">streamdata.io</a> does.</p>

<h3 id="example-using-streamdataio">Example using streamdata.io</h3>

<p>Considering the service provided by <a href="https://bitcoinaverage.com">BitcoinAverage</a>, and looking at a simple method of its  <a href="https://bitcoinaverage.com/api"><em>API</em></a>, we will write a simple code that allows us to query the following resource every 5 seconds: https://api.bitcoinaverage.com/ticker/global/EUR/</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script&gt;</span>
      <span class="nx">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
         <span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
          <span class="nx">dataType</span><span class="o">:</span> <span class="s2">&quot;json&quot;</span><span class="p">,</span>
          <span class="nx">url</span><span class="o">:</span> <span class="s2">&quot;https://api.bitcoinaverage.com/ticker/global/EUR/&quot;</span><span class="p">,</span>
          <span class="nx">success</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">});</span>
      <span class="p">},</span> <span class="mi">5000</span><span class="p">)</span>
    <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;/html&gt;</span></code></pre></div>

<p>By using <a href="https://jquery.com/">JQuery</a> for getting the benefits of the <code>ajax</code> method and the <code>setInterval</code> function (that lets us execute a function repeatedly on a time interval basis) we get the following response on the console:</p>

<p><img src="/img/posts/setIntervalClientConsole.png" alt="Streaming API proxy" /></p>

<p>As it can be seen, the <em>requests</em> are being sent every 5 seconds and the complete object is being returned regardless if it was modified.</p>

<p>From the <em>Network</em> perspective we can also discover an interesting thing</p>

<p><img src="/img/posts/setIntervalClientNetwork.png" alt="Streaming API proxy" /></p>

<p>Each <em>request</em> is proven by a new <em>GET</em>. Also, some <em>HTTP</em> response codes are <em>200 OK</em> while others are <em>304 Not Modified</em>. This last code points that the resource hasn’t changed since last time it has been requested.</p>

<h3 id="using-streamdataio">Using streamdata.io</h3>

<p>Steps for getting started with <a href="http://streamdata.io">streamdata.io</a> are really simple and can be found on its web site. As a summary:</p>

<ol>
  <li>Create an account.</li>
  <li>Once logged in we will see the Home page with a <em>dashboard</em> in it.</li>
  <li>Create an application (let’s call it “OutBitApp” for this example).</li>
  <li>Access the application.</li>
  <li>Check the configuration and make sure that the “Client Request Signature” option is disabled (<strong>only for this example, we want to avoid any not mandatory complexity</strong>).</li>
  <li>On that same screen we can see (and renew) the <em>App Token</em> (it will be required for authenticating the client code).</li>
  <li>Follow the instructions at the <a href="https://github.com/streamdataio/streamdataio-js-sdk">official GH repo</a> in order to generate the <em>SDK</em> that lets us interact with <em>streamdata.io</em>.</li>
</ol>

<p>Having accomplished these steps, the following code accesses the same <em>API</em> from the previous example but receiving <em>Push notifications</em> instead.</p>

<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;./js/streamdataio.min.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script&gt;</span>
    <span class="kd">var</span> <span class="nx">myEventSource</span> <span class="o">=</span>
      <span class="nx">streamdataio</span><span class="p">.</span><span class="nx">createEventSource</span><span class="p">(</span><span class="s2">&quot;https://api.bitcoinaverage.com/ticker/global/EUR/&quot;</span><span class="p">,</span><span class="o">*</span><span class="sr">/APP TOKEN/</span><span class="o">*</span><span class="p">);</span>
    <span class="nx">myEventSource</span><span class="p">.</span><span class="nx">onData</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;init&quot;</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}).</span><span class="nx">onPatch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;update&quot;</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}).</span><span class="nx">onError</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}).</span><span class="nx">onOpen</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;open&quot;</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">});</span>
     <span class="nx">myEventSource</span><span class="p">.</span><span class="nx">open</span><span class="p">();</span>
    <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>See the console<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span></code></pre></div>

<p><strong>Note:</strong> The “APP TOKEN” must be replaced with the one generated for the application. Remember that <em>JavaScript</em> runs on any client/browser and because of that, it’s not a good idea to place the <em>Token</em> on that code. This is only valid for proof of concept and examples.</p>

<p>Let’s check the response at the console:</p>

<p><img src="/img/posts/longPollingClientConsole.png" alt="Streaming API proxy" /></p>

<ul>
  <li>Even though these are hidden, objects are not being logged in regular intervals. This is due to the client only logs those when it receives a <em>response</em> and this only happens when the observed resource changes.</li>
  <li>The first received object (logged after an “init”) is similar to the one on the previous example, it means, the complete object. The following ones (logged after an “update”) are actually <em>arrays of objects</em>..</li>
</ul>

<p>Let’s analyze one of these <em>arrays</em>:</p>

<p><img src="/img/posts/longPollingClientparticularUpdate.png" alt="Streaming API proxy" /></p>

<p>Each object in the <em>array</em> indicates that an attribute has been replaced, and its new value is specified. Not every <em>array</em> has the same length (4, 1 and 2 as can be seen on the previous image). This indicates the quantity of changes that has been detected on each <em>response</em>.</p>

<p>Finally, let’s see what happens on the <em>network</em> view:</p>

<p><img src="/img/posts/longPollingClientNetwork.png" alt="Streaming API proxy" /></p>

<p>It can be seen an ONLY <em>request</em> to a <em>url</em> belonging to <em>streamdata</em> (the <em>proxy</em>) and as parameters, the <em>token</em> (only those clients knowing it will be able to access the app at <em>streamdata.io</em>) and the <em>url</em> of the original <em>request</em>. That request has been opened for 2.5 minutes receiving notifications every time the resource changed at the server.</p>

<h2 id="summary">Summary</h2>

<p>It’s clear how practical and even how <em>performant</em> using a <em>Streaming API</em> could be. Only thinking of the current <em>web applications</em> helps us understanding how useful is to receive notifications when the model changes at the server.<br />
But we won’t always count with a <em>Streaming API</em>. We are often hitting a 3rd party <em>API</em> and lot of times, our <em>API</em> already exists and we don’t count with time or money enough to change it (turn it into a <em>streaming API</em>). By implementing a <em>proxy</em> we can emulate that behaviour, and even if we didn’t count with the resources for implementing this solution, it would be possible to take advantage of a platform like <em>streamdata.io</em> that provides this functionality as a service in the cloud.</p>


                  <!-- <hr>

                  <ul class="pager">
                      
                      <li class="previous">
                          <a href="/es/2015/08/13/expressive-code-javscript/" data-toggle="tooltip" data-placement="top" title="Código expresivo en Javascript">&larr; Previous Post</a>
                      </li>
                      
                      
                      <li class="next">
                          <a href="/es/2015/09/09/from-api-to-streaming-api/" data-toggle="tooltip" data-placement="top" title="De una API a una Streaming API">Next Post &rarr;</a>
                      </li>
                      
                  </ul> -->
                  <div id="disqus_thread"></div>
                  <script type="text/javascript">
                      /* * * CONFIGURATION VARIABLES * * */
                      var disqus_shortname = 'ourbitblog';

                      /* * * DON'T EDIT BELOW THIS LINE * * */
                      (function() {
                          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                      })();
                  </script>
                  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
              </div>
          </div>
      </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/nohorbee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://www.facebook.com/nohorbee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/nohorbee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; OurBit 2015</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


</body>

</html>
