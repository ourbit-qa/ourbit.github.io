---
layout: post
title: Bases de datos NoSQL
lang: es
date: '2011-02-24T12:41:00.000-03:00'
author: Norberto Herz
tags:
- coachDB
- pureXML
- BigTable
- XML
- XPath
- XQuery
- DB
- NoSQL
modified_time: '2011-02-25T00:28:26.861-03:00'
thumbnail: http://4.bp.blogspot.com/-Nycm8O-OiwY/TWcSCu-EXwI/AAAAAAAABok/Aqyo6GhW8tA/s72-c/catalogue.PNG
blogger_id: tag:blogger.com,1999:blog-8314627212095006227.post-5562861963375772574
blogger_orig_url: http://ourbit.blogspot.com/2011/02/bases-de-datos-nosql.html
---

Durante estos días, estoy teniendo bastante trabajo (por eso la ausencia de posts por aquí). Uno de los proyectos con los que estoy trabajando, utiliza para la persistencia de datos un enfoque Schemaless/NoSQL aplicado sobre tecnología DB2 pureXML. De esto trata este POST.<br /><br />Primero, una aclaración respecto del término NoSQL. En un principio, surgió el término como forma de diferenciar AMPLIAMENTE una base de datos relacional (consultada mediante SQL) de una que no lo era. Luego, el término quedó como una forma simpática de abreviar <b>N</b>ot <b>O</b>nly <b>SQL</b>, indicando que las bases híbridas, pueden ser consideradas dentro del grupo de las NoSQL.<div><br /></div><div>Pero lo realmente importante, escapa al nombre e incluso a como funciona, y el foco debe realmente ser puesto en primer lugar en ¿Por qué y para qué querríamos abandonar nuestro ya conocido, probado, confiable y robusto esquema relacional?</div><div><br /></div><div>En mi caso la respuesta comienza siendo sencilla. Durante al menos los últimos 6 años de mi carrera, me he encontrado con requerimientos (en el límite de lo funcional y lo no funcional) que exigían representar entidades heterogeneas, configurables, flexibles y adaptables. Exacto, nadie dice qué tan flexibles deben ser estas entidades, pero todos afirman que deben serlo. Entonces, antes de cualquier análisis costo-beneficio, alguien siempre "salta" con el típico diseño de flexibilidad sobre un esquema relacional: "Una tabla con 2 campos. CLAVE - VALOR". Quizas algún campo más que indique a que entidad corresponden las claves y en otra tabla, una relación conteniendo el valor.</div><div style="text-align: center;"><img src="http://4.bp.blogspot.com/-Nycm8O-OiwY/TWcSCu-EXwI/AAAAAAAABok/Aqyo6GhW8tA/s400/catalogue.PNG" style="cursor:pointer; cursor:hand;width: 400px; height: 211px;" border="0" alt="" id="BLOGGER_PHOTO_ID_5577446501699051266" /></div><div><br /></div><div>Ahora bien, esta solución, intenta romper el principal paradigma de una base de datos relacional (con estructura de tablas y relaciones): "Las entidades son <b>tipadas</b>". Esto quiere decir que una entidad se define como un conjunto de campos de un tipo específico, y cada fila de la tabla representa esa entidad y ninguna otra. Este efecto, es la principal ventaja de una base de datos schemaless.</div><div><br /></div><div>Entonces, relacionando los conceptos: <b>La mayoría de los proyectos, de un tiempo a esta parte, necesitan estructuras dinámicas; las bases de datos relacionales persisten estructuras estáticas; Las bases de datos NoSql/Schemaless persisten estructuras dinámicas. ==> Las bases de datos NoSql/Schemaless se adaptan mejor a la mayoría de los proyectos de un tiempo a esta parte.</b></div><div><b><br /></b></div><div>Sumado a esto, el diseño presentado se vuelve muy ineficiente al intentar ejecutar consultas que filtren alguna entidad dinámica por un grupo de valores (consulta trivial en una entidad estática).</div><div><br /></div><div>Habiendo expuesto de esta manera el "por y para qué", indaguemos brevemente en como funciona, para luego dejar algunos links de utilidad a diferentes implementaciones tales como CoachDB, DB2 pureXML, Google BigTable.</div><div><br /></div><div><b>Supongamos un ejemplo sencillo en el cual debamos almacenar los datos de una persona: Nombre, Apellido, Fecha de nacimiento, y Teléfonos (si, más de uno). </b></div><div><b><br /></b></div><div>Un esquema posible para una base de datos relacional sería:</div><div style="text-align: center;"><img src="http://4.bp.blogspot.com/-fM_lXx79d94/TWcUfjNYxPI/AAAAAAAABo0/NV0nmkQ4ErY/s400/CopyofEsquemaCat%25C3%25A1logo.png" style="cursor:pointer; cursor:hand;width: 400px; height: 109px;" border="0" alt="" id="BLOGGER_PHOTO_ID_5577449195781539058" /></div><div style="text-align: left;">Este mismo diseño representado en una estructura schemaless, podría explicarse en una tabla con un solo campo: PERSONA (claramente, no es necesario que se halle en una tabla, puede ser un archivo de texto en un filesystem, o cualquier tipo de almacenamiento). Luego, este <b>store</b>, deberá poder representar la estructura de manera flexible.</div><div style="text-align: left;">Una buena estrategia para lograrlo es representar los datos utilizando una nomenclatura que al tiempo que describe su estructura, representa la información. Una "lenguaje" que cumple con estas características es XML. Por lo tanto, en un enfoque schemaless, un store debería almacenar la siguiente estructura (por cada entidad persistida):</div><div style="text-align: left;"><persona id="x"></persona></div><div style="text-align: left;"><span class="Apple-style-span" style="white-space: pre;"><br /><pre><br />&lt;persona id="xx"&gt;<br />&lt;nombre&gt;xxxx&lt;/nombre&gt;<br />&lt;apellido&gt;xxxx&lt;/apellido&gt;<br />&lt;fechaNacimiento&gt;xx/xx/xxxx&lt;/fechaNacimiento&gt;<br />&lt;telefonos&gt;<br />&lt;telefono id="xx" descripcion="xxxxxx"&gt;<br /> &lt;codigoPais&gt;xx&lt;/codigoPais&gt;<br /> &lt;codigoArea&gt;xx&lt;/codigoArea&gt;<br /> &lt;numero&gt;xxxxx&lt;/numero&gt;<br />&lt;/telefono&gt;<br />&lt;telefono id="xx" descripcion="xxxxxx"&gt;<br /> &lt;codigoPais&gt;xx&lt;/codigoPais&gt;<br /> &lt;codigoArea&gt;xx&lt;/codigoArea&gt;<br /> &lt;numero&gt;xxxxx&lt;/numero&gt;<br />&lt;/telefono&gt;<br />&lt;/telefonos&gt;<br />&lt;/persona&gt;<br /><br /></pre><br /></span></div><div style="text-align: left;"><div style="text-align: left;">Nótese que para lograr ser autodescriptivo, XML almacena la estructura en su contenido (repitiendo esta información gran cantidad de veces. Anotemos esto del lado de los bemoles de este enfoque).</div><div style="text-align: left;"><br /></div><div style="text-align: left;">La flexibilidad comienza cuando el mismo store, puede almacenar un XML diferente:</div><div style="text-align: left;"><div style="text-align: left; "><persona id="x" tipo="proveedor"></persona></div><div style="text-align: left; "><span class="Apple-style-span" style="white-space: pre;"><br /><span class="Apple-style-span" style="font-family: monospace; font-size: 13px; ">&lt;persona id="xx" tipo="proveedor" &gt;</span><br /><pre> &lt;nombre&gt;xxxx&lt;/nombre&gt;<br />&lt;apellido&gt;xxxx&lt;/apellido&gt;<br />&lt;fechaNacimiento&gt;xx/xx/xxxx&lt;/fechaNacimiento&gt;<br />     &lt;CUIT&gt;xxxx&lt;/CUIT&gt;<br />&lt;telefonos&gt;<br />&lt;telefono id="xx" descripcion="xxxxxx"&gt;<br /> &lt;codigoPais&gt;xx&lt;/codigoPais&gt;<br /> &lt;codigoArea&gt;xx&lt;/codigoArea&gt;<br /> &lt;numero&gt;xxxxx&lt;/numero&gt;<br />&lt;/telefono&gt;<br />&lt;telefono id="xx" descripcion="xxxxxx"&gt;<br /> &lt;codigoPais&gt;xx&lt;/codigoPais&gt;<br /> &lt;codigoArea&gt;xx&lt;/codigoArea&gt;<br /> &lt;numero&gt;xxxxx&lt;/numero&gt;<br />&lt;/telefono&gt;<br />&lt;/telefonos&gt;<br />&lt;/persona&gt;<br /><br /></pre></span></div><div style="text-align: left; "><div style="text-align: left; ">Ahora bien, ¿Cómo logramos obtener un dato dentro de esta estructura? </div><div style="text-align: left; ">Para el caso de XML, existe un standard (definido por la W3C) conocido como <a href="http://www.w3.org/TR/xpath/">XPath</a>. Este standard, permite recorrer y extraer una parte específica dentro de un XML. Por ejemplo: /persona/nombre -> retorna <pre>&lt;nombre&gt;xxxxx&lt;/nombre&gt;</pre>. Para redoblar la apuesta, W3C también definió como parte standard <a href="http://www.w3.org/XML/Query/">XQuery</a>, que permite realizar operaciones más complejas sobre un XML (Ej: <a href="http://www.stylusstudio.com/xquery_flwor.html">FLWOR</a>).</div><div style="text-align: left; "><br /></div><div style="text-align: left; ">Una base de datos que soporte estas tecnologías, podría considerarse una base NoSQL.</div><div style="text-align: left; "><br /></div><div style="text-align: left; ">Cabe aclarar que XML no es el único "lenguaje" que permite representar estructuras dinámicas. Otro ejemplo de esto es <a href="http://www.json.org/">JSON (JavaScript Object Notation)</a>, preferido por ejemplo por <a href="http://labs.google.com/papers/bigtable.html">Google BigTable</a>.</div><div style="text-align: left; "><br /></div><div style="text-align: left; ">A continuación una serie de links útiles para conocer distintas tecnologías aplicadas a NoSQL.</div><div style="text-align: left; "><ul><li>IBM DB2 pureXML:</li><ul><li>Sitio oficial:<a href="http://www-01.ibm.com/software/data/db2/xml/">http://www-01.ibm.com/software/data/db2/xml/</a></li><li>Quick Start: <a href="http://www.ibm.com/developerworks/data/library/techarticle/dm-0603saracco2/">http://www.ibm.com/developerworks/data/library/techarticle/dm-0603saracco2/</a></li></ul><li>Tutorial XPATH: <a href="http://www.w3schools.com/xpath/default.asp">http://www.w3schools.com/xpath/default.asp</a></li><li>Tutorial XQuery: <a href="http://www.w3schools.com/xquery/default.asp">http://www.w3schools.com/xquery/default.asp</a></li><li>CoachDB: <a href="http://couchdb.apache.org/">http://couchdb.apache.org/</a></li><li>BigTable: <a href="http://blogs.xingular.net/santiago/bases-de-datos/entendiendo-el-modelo-de-datos-de-google-big-table/">http://blogs.xingular.net/santiago/bases-de-datos/entendiendo-el-modelo-de-datos-de-google-big-table/</a></li><li>NoSql: <a href="http://nosql-database.org/">http://nosql-database.org/</a></li></ul>Espero les interese el tema y lo investiguen. Queda pendiente combinar estos conceptos con algo de almacenamiento distrubuido, teorema CAP, escalabilidad y performance, pero creo que es mucho para un solo POST.</div></div></div></div>
