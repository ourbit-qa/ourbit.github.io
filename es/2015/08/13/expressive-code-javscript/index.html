<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Escribiendo código expresivo en Javascript utilizando los métodos forEach, filter, map, reduce, every y some">

    <title>Código expresivo en Javascript - OurBit</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-55d608d53393428d" async="async"></script>
    <!-- Post Header -->
    <!--Google Analytics-->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-66576431-1', 'auto');
      ga('send', 'pageview');

    </script>

    <link rel="canonical" href="http://localhost:4000/es/2015/08/13/expressive-code-javscript/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/es/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/es/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/es/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/es/">OurBit</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/es/">Inicio</a>
                </li>
                <li>
                    <a href="/es/archives">archivo</a>
                </li>
                <li><a>|</a></li>
                <li>
                  
                      <a href="http://norbertoherz.com/es">norbertoherz.com</a>
                  

                </li>
                <li>
                
                    
                    <a href="/2015/08/13/expressive-code-javscript/" >English Version</a>
                
                </li>

                <!--  -->
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <script>
$(window).scroll(function(e) {


     if($(window).scrollTop() <= $(document).height()/2) {
        oVal = ($(window).scrollTop() / 170);
    } else {
        oVal = ($(document).height() -
        $(window).scrollTop() -
        $(window).height()) / 170;

    }



    $(".blur").css("opacity", oVal);
    

});
</script>

<div class="img-src" style="background-image: url('/es/img/header-background.jpg')"></div>
<div class="img-src blur" style="background-image: url('/es/img/header-background-blur.jpg')"></div>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Código expresivo en Javascript</h1>
                    
                    <h2 class="subheading">Funciones de orden superior</h2>
                    
                    <span class="meta">Publicado por nohorbee el
                      
                      
  
  13 de
  
  Agosto
    


de 2015


                    </span>
                </div>
            </div>
        </div>
    </div>
</header>
<!-- Post Content -->
<article>
    <div class="content-wrapper">
      <div class="container">
          <div class="row">
              <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

  				<p>Hay varios (si no demasiados) aspectos a tener en cuenta al momento de escribir una pieza de código: <em>performance, mantenibilidad y legibilidad</em>, por mencionar algunos.
Un aspecto que me resulta particularmente interesante es el denominado “expresividad” y significa “la habilidad de enunciar lo que se está haciendo”.</p>

<p>Como buen <em>Javascript Hipster (“A mi me gustaba antes de que fuera popular”)</em> me gustaría mostrar algunos ejemplos de cómo <em>Javascript</em> nos permite ser realmente expresivos trabajando con <em>arrays</em> (y algunas funciones en particular): <em>forEach, filter, map, reduce, every</em> and <em>some</em>.
<!--MORE--></p>

<p>Si bien habitualmente la característica de “Expresivo” se le atribuye al lenguaje, en todos los lenguajes se puede ser más o menos expresivo al escribir diferentes versiones de código que hagan lo mismo. De esta manera, sería más preciso definir a una pieza de código como “expresiva” si realmente es capaz de enunciar lo que está haciendo.</p>

<p>Tomemos como ejemplo un conjunto de personas:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">var</span> <span class="nx">persons</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;John Doe&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="o">:</span> <span class="mi">27</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="o">:</span> <span class="mi">176</span><span class="p">},</span>
  <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;John Doe Jr.&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="o">:</span> <span class="mi">22</span><span class="p">},</span>
  <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;Jane Doe&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="o">:</span> <span class="mi">24</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="o">:</span> <span class="mi">127</span><span class="p">},</span>
  <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;Julian Doe&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="o">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="o">:</span> <span class="mi">160</span><span class="p">}</span>
<span class="p">];</span></code></pre></figure>

<p>Ahora, recorramos este <em>array</em> y por cada persona imprimamos “<em>Name</em> is <em>age</em> years old”.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">persons</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">persons</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="nx">persons</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">age</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Este código es bastante simple, corto y podríamos decir que es bastante legible. Pero esto no lo hace necesariamente <strong>expresivo</strong>. Lo que queríamos hacer era: Imprimir “<em>Name</em> is <em>age</em> years old” por cada persona. Esto es lo que dice el código que acabamos de escribir:</p>

<ol>
  <li>Inicializar una variable <em>i</em> con el valor <em>0</em>.</li>
  <li>Siempre y cuando la variable sea menor a la cantidad de personas, incrementarla y ejecutar el siguiente bloque de código:<br />
  2.1. Obtener el nombre de la persona en la posición indicada por la variable previamente inicializada.<br />
  2.2. Concatenarle un espacio, un guión y luego otro espacio.<br />
  2.3. Concatenarle la edad de la persona en la posición indicada por la variable previamente inicializada.<br />
  2.4. <em>Loggear</em> el resultado en la consola.</li>
</ol>

<p>Comencemos por quitar la línea dentro del <em>for</em> y ubicarla dentro de una función que reciba una <em>persona</em> como parámetro e imprima el patrón especificado.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">var</span> <span class="nx">printPattern</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot; - &quot;</span> <span class="o">+</span> <span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">persons</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">printPattern</span><span class="p">(</span><span class="nx">persons</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
<span class="p">}</span></code></pre></figure>

<p>Si estás pensando “esto no tiene nada que ver con <em>Javascript</em> y las funciones de sus <em>arrays</em>”, estás en lo cierto, pero no te impacientes.<br />
No hicimos más que <em>encapsular</em> una funcionalidad para ocultar su complejidad. <em>Encapsulamiento</em> es un concepto habitualmente relacionado al Paradigma de Programación orientada a objetos, pero en realidad puede lograrse de muchas maneras, y las <em>funciones</em> son una forma ancestral de lograrlo. El objetivo de <em>encapsular</em> código no es el de hacerlo más expresivo, pero en la mayoría de los casos, es un efecto colateral.</p>

<p>Si leemos nuevamente el código (y obviamos describir la nueva función):</p>

<ol>
  <li>Inicializar una variable <em>i</em> con el valor <em>0</em>.</li>
  <li>Siempre y cuando la variable sea menor a la cantidad de personas, incrementarla e</li>
  <li>Imprimir el patrón para la persona en la posición indicada por la variable previamente inicializada.</li>
</ol>

<h3 id="arrayprototypeforeach">Array.Prototype.forEach</h3>
<p>Si bien el código se ha vuelto un poco más expresivo, parece estar más preocupado por la variable <em>i</em>, su inicialización, y su cota, que por la persona en sí misma.<br />
Afortunadamente hay otras formas de recorrer un <em>array</em>. Por ejemplo el método <code>Array.prototype.forEach(function)</code>.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">printPattern</span><span class="p">);</span></code></pre></figure>

<p>Si leemos nuevamente el código:</p>

<ol>
  <li>Por cada persona, imprimir el patrón.</li>
</ol>

<p>De esta forma, el código <em>hace</em> y <em>expresa</em> exactamente lo que queremos.<br />
Pero, si bien la lectura resulta más simple, es necesario comprender que es lo que está ocurriendo detrás del telón.<br />
En primer lugar, algo a destacar de <em>Javascript</em> es que <em>todo (o casi todo) es un mensaje.</em> Esto significa que objetos, funciones, métodos y valores son mensajes (o expresiones) y como tales pueden ser pasadas como parámetros.<br />
A diferencia del <em>for</em> que es una instrucción, el <em>forEach</em> es un método del objeto <em>Array</em> (o de su <em>prototipo</em>). Combinando estos conceptos, <em>forEach</em> recorre el <em>array</em> y en cada iteración invoca a la función que recibió como parámetro. En dicha invocación, <em>forEach</em> le pasa como parámetro a la otra función, el elemento que está siendo iterado.<br />
Una implementación muy básica del <em>forEach</em> podría ser:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">forEach</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">func</span><span class="p">(</span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Adicionalmente, el <em>forEach</em> recibe un segundo parámetro opcional que representa una función que será invocada cuando se haya finalizado la recorrida del <em>array</em>. En los ejemplos que se están mostrando esto puede parecer inútil, pero cuando se está en un entorno de programación <em>asincrónica</em> (como <a href="http://nodejs.org">NodeJS</a>), este tipo de implementaciones se vuelve indispensable.</p>

<p>Aún más útiles quizá resulten 2 parámetros adicionales que <strong>el <em>forEach</em> le pasa a la función especificada en el primer parámetro:</strong></p>

<ul>
  <li><em>index</em>: El índice del elemento que está siendo iterado.</li>
  <li><em>array</em>: El <em>array</em> completo.</li>
</ul>

<p>El <em>forEach</em> no devuelve ningún resultado, pero entre las acciones realizadas dentro de la función invocada, es posible modificar el <em>array</em> que está siendo iterado (lo cual, como veremos, deberá hacerse con cuidado).</p>

<h3 id="no-apto-para-menores-de-25-años">No apto para menores de 25 años</h3>
<p>Supongamos que en un bar muy exclusivo no se admiten menores de 25 años. Podríamos intentar escribir un código que elimine del <em>array</em> aquellas personas que no alcancen dicha edad. El código podría ser:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="o">&lt;</span><span class="mi">25</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="nx">persons</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">printPattern</span><span class="p">);</span></code></pre></figure>

<p><strong>Nota</strong>: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice"><em>splice</em></a> es útil para eliminar elementos de un <em>array</em>.</p>

<p>Si ejecutamos este código, vamos a obtener el siguiente resultado:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span></span><span class="go">John Doe - 27</span>
<span class="go">Jane Doe - 24</span>
<span class="go">Julian Doe - 32</span></code></pre></figure>

<p>Por algún motivo, Jane Doe logró vencer la seguridad de nuestro bar, e ingresar. Dicho motivo es causa de incontables <em>bugs</em> en incontables piezas de código.<br />
En cada iteración, <em>index</em> incrementa 1. La primera vez (<em>index=0</em>) encontramos a John Doe de 27 años. Queda en el <em>array</em>. La segunda vez (<em>index=1</em>), encontramos a John Doe Jr de 3 años (quien claramente no debería estar en nuestro bar). Al removerlo del <em>array</em> Jane Doe pasa a estar en el <em>index 1</em> y Julian Doe en el <em>index 2</em>. La tercera iteración (<em>index=2</em>) aparece Julian Doe. Es decir que Jane Doe ha sido salteada. <strong>Es como si el guardia de seguridad se diera vuelta cada vez que saca a alguien de la fila del bar y en ese momento dejara pasar a una persona sin importar su edad.</strong><br />
No siempre es buena idea modificar el <em>array</em> que se está iterando. Como soluciones alternativas, se puede utilizar un <em>array</em> auxiliar y sobreescribir el original una vez que ya se haya finalizado la iteración.</p>

<p>Pero más allá de el mal funcionamiento del código anterior, analicemos su <strong>expresividad</strong>:</p>

<ol>
  <li>Por cada persona:<br />
  1.1. Verificar si supera o iguala los 25 años.<br />
  1.2. Si no lo hace, remover del <em>array</em> 1 posición comenzando en <em>index</em>.</li>
  <li>Por cada persona, imprimir el patrón (hay que prestar atención al código para entender que es “por cada persona que haya quedado en el <em>array</em>”).</li>
</ol>

<p>No parece ser tan grave, pero seguimos teniendo conocimiento del <em>array</em>, el <em>index</em> y la lógica para realizar la comparación. Además, si quisiéramos reutilizar este código para quitar menores de edad, deberíamos duplicarlo.<br />
Comencemos por atacar este segundo problema (al menos parte del mismo).</p>

<h3 id="funciones-que-crean-funciones">Funciones que crean funciones</h3>
<p>Esta es una característica de <em>Javascript</em> que, bien utilizada, nos permite escribir código expresivo y altamente reutilizable.<br />
Tomemos por ejemplo el siguiente código:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">function</span> <span class="nx">olderThan25</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="o">&lt;</span><span class="mi">25</span><span class="p">)</span> <span class="p">}</span>
 <span class="p">}</span>
<span class="kd">var</span> <span class="nx">older</span> <span class="o">=</span> <span class="nx">olderThan25</span><span class="p">();</span></code></pre></figure>

<p><em>olderThan25</em> está devolviendo una función que recibe una persona y devuelve <em>true</em> si la persona es mayor de (o tiene exactos) 25 años. Es decir que, al asignar el resultado de su ejecución a la variable <em>older</em>, <code>older(person)</code> realizará la evaluación antes mencionada.<br />
Entonces,</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">older</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;John Doe Jr.&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="o">:</span> <span class="mi">3</span><span class="p">}));</span></code></pre></figure>

<p>imprime <code>false</code></p>

<p>Siguiendo este mismo concepto, podemos aún lograr un código más reutilizable e incluso más expresivo. Pasemos como parámetro el “umbral” de edad que queremos evaluar.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">function</span> <span class="nx">olderThan</span><span class="p">(</span><span class="nx">threshold</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="o">&lt;</span><span class="nx">threshold</span><span class="p">)</span> <span class="p">}</span>
 <span class="p">}</span>
<span class="kd">var</span> <span class="nx">olderThan25</span> <span class="o">=</span> <span class="nx">olderThan</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">olderThan3</span> <span class="o">=</span> <span class="nx">olderThan</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span></code></pre></figure>

<p>Ahora, podemos crear cuantas funciones queramos con diferentes umbrales de edad, y nomenclarlas de forma tal que representen lo que hacen.<br />
Aplicando al código anterior (que intentaba remover a los menores de 25 años):</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">olderThan25</span><span class="p">(</span><span class="nx">person</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="nx">persons</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">printPattern</span><span class="p">);</span></code></pre></figure>

<ul>
  <li>El código sigue sin funcionar (el problema descripto anteriormente sigue allí).</li>
  <li>Si bien la legibilidad del código mejoró, se sigue leyendo “si la persona es mayor de 25, remover una posición del <em>array</em> comenzando en <em>index</em>”. Es decir que la expresividad sigue siendo similar.</li>
</ul>

<h3 id="arrayprototypefilter">Array.Prototype.filter</h3>

<p>Afortunadamente, <em>Javascript</em> nos da un método del <em>array</em> que hace exactamente lo que queremos.<br />
El método <em>filter</em> recibe 2 parámetros:</p>

<ul>
  <li><em>callback</em>: La función que evalua la condición que decide si el elemento que está siendo iterado, debe pertenecer (deberá devolver <em>true</em> si el elemento debe pertenecer al nuevo grupo, y <em>false</em> en caso contrario).</li>
  <li><em>contextObject</em> (opcional): El objeto que será utilizado como <em>this</em> dentro de la función <em>callback</em>.</li>
</ul>

<p>A su vez, <em>filter</em> pasa a <em>callback</em> 3 parámetros (al igual que lo hacía <em>forEach</em>):</p>

<ul>
  <li><em>element</em>: El elemento que está siendo iterado.</li>
  <li><em>index</em>: La posición de dicho elemento dentro del <em>array</em>.</li>
  <li><em>array</em>: El <em>array</em> que está siendo iterado.</li>
</ul>

<p>A diferencia del <em>forEach</em>, <em>filter</em> devuelve un <strong>nuevo</strong> <em>array</em> con los elementos que pasen la prueba evaluada en <em>callback</em>.</p>

<p>Teniendo en cuenta este nuevo método, el siguiente código resuelve el requerimiento expresado anteriormente:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">olderThan25</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">printPattern</span><span class="p">);</span></code></pre></figure>

<p>Respecto de su expresividad, puede ser leído como:</p>

<ol>
  <li>Filtrar las personas <strong>que no</strong> sean mayores de 25 y por cada una imprimir el patrón.</li>
</ol>

<p>Un problema de este método (respecto de su expresividad) es el nombre <em>filter</em> (y/o el hecho de remueva el elemento cuando <em>callback</em> devuelve <em>false</em>). Eso haría que sea lea “filtrar los mayores de 25”, cuando en realidad se está haciendo lo contrario. <em>Nada es perfecto</em>.</p>

<h3 id="cuida-tu-peso">Cuida tu peso</h3>

<p>Hemos logrado trabajar con cada persona de nuestro grupo, y realizar operaciones con cada una de ellas. Pero muchas veces, es necesario trabajar con el grupo como un todo.<br />
Supongamos que <em>nuestras</em> personas están subiendo a un ascensor. Por motivos de seguridad, los ascensores más modernos incluyen una balanza para asegurarse de que no se haya superado el peso máximo soportado por el mismo. Intentemos evitar la vergüenza de escuchar la chicharra indicando que nos hemos excedido y calculemos el peso total previamente:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">var</span> <span class="nx">totalWeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">persons</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">totalWeight</span> <span class="o">+=</span> <span class="nx">person</span><span class="p">.</span><span class="nx">weight</span> <span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">totalWeight</span><span class="p">);</span></code></pre></figure>

<p>Algunas observaciones acerca de este código:</p>

<ul>
  <li>Como vimos, <em>forEach</em> recibe como primer parámetro una función. Hasta aquí, solíamos crear la función como un paso previo y pasar el nombre de la función como parámetro. Pero, como <em>function</em> es una expresión que devuelve una función, la sintaxis de <em>Javascript</em> nos permite definir la función directamente en el lugar donde escribiríamos el valor del parámetro. En particular, esta función no tiene nombre, lo que la convierte en una <strong>función anónima</strong>. Los diferentes tipos de funciones y las diferentes formas de definirlas, ameritan un <em>post</em> en sí mismo.</li>
  <li>Como <em>forEach</em> no devuelve nada, es necesario definir una variable externa que acumule el valor de la suma.</li>
  <li>El código que vamos a generar, <strong>en mi opinión</strong> no es <em>automáticamente</em> más expresivo que el que ya generamos. Pero sin duda, se vuelve increíblemente entendible cuando comprendemos el significado e importancia de los métodos <em>map</em> y <em>reduce</em>.</li>
</ul>

<p>Paso a paso. Primero consideremos la sensibilidad de la gente respecto de su peso e intentemos mantener cierta confidencialidad. Obtengamos un nuevo <em>array</em> que solo tenga los pesos de las personas de nuestro grupo.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">var</span> <span class="nx">weights</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">persons</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">weights</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">person</span><span class="p">.</span><span class="nx">weight</span><span class="p">;</span>
<span class="p">});</span></code></pre></figure>

<p>Este código puede leerse de la siguiente manera:</p>

<ol>
  <li>Crear un array vacío llamado <em>weights</em></li>
  <li>Por cada persona, invocar una función que reciba a dicha persona y el índice de la misma en el <em>array</em> original.</li>
  <li>La función obtiene el peso de la persona y lo asigna a la posición indicada en el nuevo <em>array</em>.</li>
</ol>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">weights</span><span class="p">);</span></code></pre></figure>

<p>imprime</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span></span><span class="go">[ 176, 22, 127, 160 ]</span></code></pre></figure>

<h3 id="arrayprototypemap">Array.prototype.map</h3>

<p>En general, llamamos al proceso de asociar los elementos de un conjunto, con los elementos de otro conjunto “<a href="https://en.wikipedia.org/wiki/Map_(mathematics)">mapear</a>”, y el criterio de dicha asociación puede variar dependiendo la función utilizada.<br />
Es decir, que el código que escribimos anteriormente “mapea las personas con/por su peso”.<br />
Sería bueno poder escribir eso mismo en <em>Javascript</em> de la siguiente manera:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">weight</span><span class="p">);</span></code></pre></figure>

<p>De hecho, definiendo <em>weight</em> como una función que dada una persona, devuelva su peso, la línea anterior hace <strong>exactamente</strong> lo que dice.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">function</span> <span class="nx">weight</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">person</span><span class="p">.</span><span class="nx">weight</span><span class="p">;</span> <span class="p">}</span></code></pre></figure>

<p>El método <em>map</em>, recibe los mismos 2 parámetros que <em>filter</em>:</p>

<ul>
  <li><em>callback</em>: La función que determina el criterio de asociación (deberá devolver el valor a mapear con cada elemento).</li>
  <li><em>contextObject</em> (opcional): El objeto que será utilizado como <em>this</em> dentro de la función <em>callback</em>.</li>
</ul>

<p>A su vez, <em>map</em> pasa a <em>callback</em> 3 parámetros (al igual que lo hacían <em>forEach</em> y <em>filter</em>):</p>

<ul>
  <li><em>element</em>: El elemento que está siendo iterado.</li>
  <li><em>index</em>: La posición de dicho elemento dentro del <em>array</em>.</li>
  <li><em>array</em>: El <em>array</em> que está siendo iterado.</li>
</ul>

<p><em>map</em> devuelve un <strong>nuevo</strong> <em>array</em> con los elementos del segundo conjunto. En nuestro ejemplo, un <em>array</em> con los pesos de las personas.</p>

<p>Ahora bien, volviendo a nuestro ejemplo, los pesos por separado no nos ayudan a determinar si es peligroso o no activar el ascensor. Aún debemos obtener el peso total.</p>

<p>Si siguiéramos el enfoque anterior, pero aprovechando la función <em>map</em>, nuestro código quedaría así:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">var</span> <span class="nx">totalWeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">persons</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">weight</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">weight</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">totalWeight</span> <span class="o">+=</span> <span class="nx">weight</span> <span class="p">;</span>
<span class="p">});</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">totalWeight</span><span class="p">);</span></code></pre></figure>

<p>Es decir que primero obtenemos el <em>array</em> de pesos y luego lo iteramos realizando la acumulación. Es una pequeña (casi insignificante) mejora respecto de nuestra versión anterior.</p>

<h3 id="arrayprototypereduce">Array.prototype.reduce</h3>

<p>El término <em>reduce</em> resulta, al menos para mi, poco descriptivo respecto del objetivo de este método. Otros lenguajes (asociados al paradigma <em>funcional</em>) suelen referirse a esta función como <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)"><em>fold</em></a>. Pero una buena forma de entenderlo es pensar en <em>reduce</em> como “resumir”. Queremos encontrar un solo valor que <em>resuma</em> de alguna manera a todos los demás. Por ejemplo, 10 resume a 4, 3, 2 y 1 si consideramos a la suma como forma de resumir. 24 resume a 4, 3, 2, 1 si consideramos a la multiplicación como forma de resumir.<br />
Entonces, Definiendo <em>sum</em> como</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span> <span class="p">}</span></code></pre></figure>

<p>y considerando el siguiente código</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span> <span class="nx">persons</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">weight</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span></code></pre></figure>

<p>se podría leer: resumir mediante la suma, el peso de las personas. O, sumar el peso de las personas.</p>

<p>El método <em>reduce</em>, recibe 2 parámetros:</p>

<ul>
  <li><em>callback</em>: La función que contiene la lógica de reducción (la forma de resumir).</li>
  <li><em>initialValue</em> (opcional): El valor inicial del <em>acumulador</em>.</li>
</ul>

<p>A su vez, <em>reduce</em> pasa a <em>callback</em> 4 parámetros:</p>

<ul>
  <li><em>previousValue</em>: El resultado de la última ejecución de <em>callback</em> o <em>initialValue</em> (la primera vez que se ejecuta).</li>
  <li><em>currentValue</em>: El valor que está siendo iterado.</li>
  <li><em>index</em>: La posición de dicho valor dentro del <em>array</em>.</li>
  <li><em>array</em>: El <em>array</em> que está siendo iterado.</li>
</ul>

<p><em>reduce</em> devuelve un <strong>único</strong> valor que coincide con el resultado de la última ejecución de <em>callback</em>.</p>

<p>Hay algunas características de <em>reduce</em> que podrían catalogarlo como un método recursivo. En lugar de pensar a <em>reduce</em> como una función que itera el <em>array</em> aplicando <em>callback</em>, podríamos pensarlo como una función que toma la primera posición del <em>array</em> y aplica <em>callback</em> pasando esta posición y el resultado de <em>reduce</em> para un segundo <em>array</em> que va desde la segunda hasta la última posición del primer <em>array</em>. Al usarlo, esto es transparente, pero saberlo nos ayuda a entender cómo funciona, por qué <strong>acumula</strong> y cómo funciona el <em>initialValue</em>.</p>

<h3 id="una-visita-al-autocine">Una visita al autocine</h3>

<p>Las personas salieron del ascensor, subieron al auto y partieron con rumbo al auto-cine. Eligieron una película no apta para menores de 18 años. Al intentar ingresar, debemos preguntar si <strong>todas</strong> las personas en el auto alcanzan dicha edad.<br />
Hay muchas formas de lograrlo. Entre ellas:</p>

<ul>
  <li>Iterar y preguntar</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">areOlder</span> <span class="o">=</span> <span class="nx">areOlder</span> <span class="o">&amp;&amp;</span> <span class="nx">olderThan18</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>Estamos utilizando la función <em>olderThan(threshold)</em> para generar la función <em>olderThan18</em>.</p>

<ul>
  <li>Reducir mediante el operador lógico “Y”</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">isPreviousOlder18</span><span class="p">,</span> <span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">isPreviousOlder18</span> <span class="o">&amp;&amp;</span> <span class="nx">olderThan18</span><span class="p">(</span><span class="nx">person</span><span class="p">));</span>
<span class="p">},</span><span class="kc">true</span><span class="p">);</span></code></pre></figure>

<ul>
  <li>Mapear al <em>array</em> de edades y reducir mediante el operador lógico “Y”</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">person</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">isPreviousGreater18</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">isPreviousGreater18</span> <span class="o">&amp;&amp;</span> <span class="nx">greaterThan18</span><span class="p">(</span><span class="nx">age</span><span class="p">));</span>
<span class="p">},</span><span class="kc">true</span><span class="p">);</span></code></pre></figure>

<p>Es similar a la anterior, pero antes de <em>reducir</em>, obtenemos el <em>array</em> de edades (y por lo tanto, en lugar de utilizar una función que reciba una persona y compare su edad, utilizamos una similar pero que compare directamente la edad. <em>greaterThan18</em> es generada de forma similar que <em>olderThan18</em>).</p>

<p>Todas estas soluciones tienen un problema (u oportunidad de mejora): Evalúan todo el <em>array</em> sin importar lo que ocurra. En nuestro caso, evaluando el segundo elemento podríamos concluir que no todas las personas son mayores de 18. En evaluaciones de expresiones <em>booleanas</em> esto se conoce como “evaluación de cortocircuito”.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kc">true</span> <span class="o">||</span> <span class="nx">whatever</span> <span class="c1">// -&gt; true</span>
<span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="nx">whatever</span> <span class="c1">// -&gt; false</span></code></pre></figure>

<p>En ambos casos, es innecesario evaluar <em>whatever</em>.</p>

<p>Esto parece ser irrelevante en un <em>array</em> de 4 elementos. Pero ¿qué pasaría si tuviéramos un colectivo, tren o avión intentando ingresar al auto-cine? Además del posible problema de espacio del predio, nuestras soluciones estarían ocupando ciclos de procesamiento innecesarios, lo que se conoce como <strong>mala performance</strong>.<br />
La forma de solucionar esto es <em>rompiendo</em> las iteraciones cuando no es necesario seguir evaluando. La instrucción <em>break</em> hace exactamente eso, pero no es aplicable a los métodos que estamos utilizando (es aplicable al <em>for</em> clásico). Existen otras “técnicas” para salir de estos métodos, pero ninguna es elegante ni recomendable (por ejemplo, podríamos asignar “0” a <em>array.length</em>, si no necesitaramos seguir trabajando con el <em>array</em>. O hacer una copia del mismo, para poder cambiar el <em>length</em> sin problemas. También podríamos <em>lanzar una excepción</em> y <em>capturarla</em> inmediatamente al salir del método).</p>

<p>Pero hay un motivo por el cual este problema se presenta al utilizar estos métodos. En el caso del <em>forEach</em> el motivo es incluso explícito en el nombre de la función. <strong>Por cada</strong> elemento de un <em>array</em> implica que <strong>todos</strong> los elementos van a ser iterados.</p>

<h3 id="every-some">Every-Some</h3>

<p>Volviendo al tema de la <em>expresividad</em>, ninguna de las soluciones resultan demasiado expresivas (hagan el ejercicio de identificar lo que cada una está diciendo y lo que cada una está haciendo). El enunciado debería ser más sencillo. Verificar que todas las personas sean mayores de 18.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">every</span><span class="p">(</span><span class="nx">olderThan18</span><span class="p">);</span></code></pre></figure>

<p>Esta solución dice y hace exactamente lo que buscamos. Devuelve <em>true</em> si todas las personas son mayores de 18 años. Caso contrario, devuelve <em>false</em>.<br />
Además de ser altamente expresiva, <em>every</em> respeta la evaluación de cortocircuito, es decir que dejará de iterar ni bien encuentre una persona que no cumpla la condición.</p>

<p>El método <em>every</em> recibe 2 parámetros:</p>

<ul>
  <li><em>callback</em>: La función que evalua la condición a cumplir (deberá devolver <em>true</em> o <em>false</em>).</li>
  <li><em>contextObject</em> (opcional): El objeto que será utilizado como <em>this</em> dentro de la función <em>callback</em>.</li>
</ul>

<p>A su vez, <em>every</em> pasa a <em>callback</em> 3 parámetros (al igual que lo hacían los demás métodos):</p>

<ul>
  <li><em>element</em>: El elemento que está siendo iterado.</li>
  <li><em>index</em>: La posición de dicho elemento dentro del <em>array</em>.</li>
  <li><em>array</em>: El <em>array</em> que está siendo iterado.</li>
</ul>

<p><em>every</em> devuelve <em>true</em> si todos los elementos iterados cumplieron con la condición, y <em>false</em> si al menos un elemento no lo hace (y deja de iterar cuando lo encuentra).</p>

<h3 id="en-busca-de-una-película-apta">En busca de una película apta</h3>

<p>Las restricciones de edad en las películas deben ser respetadas. Y si bien nuestras personas no  encontraron ninguna película apta para todo público, apareció un nuevo estreno que puede ser vista por menores con la supervisión de un adulto. Dejando de lado el criterio del adulto, escribamos la solución que nos permita evaluar si alguna persona es mayor de 18 años. Pero antes de comenzar a mostrar todas las alternativas (como hicimos con el caso anterior <em>every</em>) pensemos ¿no existirá algún otro método que diga y haga lo estamos buscando?<br />
Mi respuesta rápida es <strong>sí</strong>:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="nx">olderThan18</span><span class="p">);</span></code></pre></figure>

<p>El método <em>some</em> recibe 2 parámetros:</p>

<ul>
  <li><em>callback</em>: La función que evalua la condición a cumplir (deberá devolver <em>true</em> o <em>false</em>).</li>
  <li><em>contextObject</em> (opcional): El objeto que será utilizado como <em>this</em> dentro de la función <em>callback</em>.</li>
</ul>

<p>A su vez, <em>some</em> pasa a <em>callback</em> 3 parámetros (al igual que lo hacían los demás métodos):</p>

<ul>
  <li><em>element</em>: El elemento que está siendo iterado.</li>
  <li><em>index</em>: La posición de dicho elemento dentro del <em>array</em>.</li>
  <li><em>array</em>: El <em>array</em> que está siendo iterado.</li>
</ul>

<p><em>some</em> devuelve <em>false</em> si ningún elemento cumple con la condición, y <em>true</em> si al menos un elemento lo hace (y deja de iterar cuando lo encuentra).</p>

<h3 id="performance">Performance</h3>

<p>Como mencioné al comienzo del <em>post</em>, la <em>expresividad</em> es solo uno de muchos aspectos a considerar. Muchas veces, estos aspectos entran en conflicto y es necesario evaluar cuál prima.<br />
Consideremos el siguiente problema: Debo obtener un <em>array</em> con las personas con peso menor a 130 libras, que tengan más de 10 años.<br />
Con todo lo que hemos visto, naturalmente podríamos pensar que la siguiente solución es ideal:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">olderThan10</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">softerThan130</span><span class="p">);</span></code></pre></figure>

<p>La realidad es que esta solución no es ideal, tan solo es expresiva.<br />
Al filtrar, estamos iterando el <em>array</em>. Al filtrar 2 veces, estamos iterando 2 <em>arrays</em>. Si <em>persons</em> contiene N elementos y M son mayores de 10, la solución anterior recorrerá N + M elementos. La siguiente solución puede ser un poco menos expresiva pero nos asegura que solo se recorrerán N elementos:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="nx">persons</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">olderThan10AndsofterThan130</span><span class="p">)</span></code></pre></figure>

<p>considerando</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span></span><span class="kd">function</span> <span class="nx">olderThan10AndsofterThan130</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">olderThan10</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">softerThan130</span><span class="p">(</span><span class="nx">person</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Al negociar un aspecto por otro, es necesario considerar el caso de uso. Si nuestros <em>arrays</em> contienen familias (es decir, pocos elementos), quizá podamos darnos el lujo de tener el código más expresivo. Si estamos procesando el padrón electoral completo, mejor preocuparse por la <em>performance</em>.</p>

<h3 id="conclusión">Conclusión</h3>

<p>La misma sintaxis de <em>Javascript</em> nos permite trabajar con partes buenas de los paradigmas <em>estructurado</em>, <em>orientado a objetos</em> y <em>funcional</em>. Las buenas prácticas de cada paradigma pueden favorecernos a la hora de mejorar algunos aspectos de nuestro código. En la mayoría de los casos, al mejorar un aspecto, estaremos empeorando otros (Ej: Mayor Expresividad -&gt; Menor Performance). Muchas veces estos aspectos se conjugarán de formas más complejas (Ej: Mayor Performance y Buena Expresividad -&gt; Poca Flexibilidad). Es parte de nuestro trabajo cuando escribimos una pieza de código, evaluar qué aspectos queremos favorecer y cuáles podemos castigar. La mayoría de las veces caeremos en la trampa y favoreceremos los aspectos que más nos gusten. Eso es algo a evitar. Para saber qué aspectos favorecer, la mejor opción es analizar el caso de uso.</p>


                  <!-- <hr>

                  <ul class="pager">
                      
                      <li class="previous">
                          <a href="/es/jekyll/update/2015/08/03/moving-to-gh-pages/" data-toggle="tooltip" data-placement="top" title="Mudanza a GitHubPages">&larr; Previous Post</a>
                      </li>
                      
                      
                      <li class="next">
                          <a href="/es/2015/09/09/from-api-to-streaming-api/" data-toggle="tooltip" data-placement="top" title="De una API a una Streaming API">Next Post &rarr;</a>
                      </li>
                      
                  </ul> -->
                  <div id="disqus_thread"></div>
                  <script type="text/javascript">
                      /* * * CONFIGURATION VARIABLES * * */
                      var disqus_shortname = 'ourbitblog';

                      /* * * DON'T EDIT BELOW THIS LINE * * */
                      (function() {
                          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                      })();
                  </script>
                  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
              </div>
          </div>
      </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/es/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>


                    <li>
                        <a href="skype:norberto.herz">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-skype fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>

                    
                    <li>
                        <a href="https://twitter.com/nohorbee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://www.facebook.com/nohorbee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    

                    <li>
                        <a href="https://www.linkedin.com/pub/norberto-herz/5/887/177">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>

                    
                    <li>
                        <a href="https://github.com/nohorbee">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; OurBit 2017</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/es/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/es/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/es/js/clean-blog.min.js "></script>

<script type="text/javascript">
var addthis_share = addthis_share || {}
addthis_share = {
  passthrough : {
    twitter: {
      via: "nohorbee"
    }
  }
}
</script>


</body>

</html>
